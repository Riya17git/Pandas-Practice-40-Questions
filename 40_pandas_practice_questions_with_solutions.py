# -*- coding: utf-8 -*-
"""40 Pandas Practice questions with solutions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hnj-qyg_mX-FSPIT4D79o6QS-dJdEUaf
"""

import pandas as pd
import numpy as np

"""## Data"""

data = {'animal': ['cat', 'cat', 'snake', 'dog', 'dog', 'cat', 'snake', 'cat', 'dog', 'dog'],
        'age': [2.5, 3, 0.5, np.nan, 5, 2, 4.5, np.nan, 7, 3],
        'visits': [1, 3, 2, 3, 2, 3, 1, 1, 2, 1],
        'priority': ['yes', 'yes', 'no', 'yes', 'no', 'no', 'no', 'yes', 'no', 'no']}

labels = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']

# Q1 Create a DataFrame df from this dictionary data which has the index labels.

df = pd.DataFrame(data,index=labels)
df

# 5. Display a summary of the basic information about this DataFrame and its data
# (hint: there is a single method that can be called on the DataFrame).

df.describe()

# 6 Select just the 'animal' and 'age' columns from the DataFrame df

df[['animal','age']]

# 7 Select the data in rows [3, 4, 8] and in columns ['animal', 'age']

df.iloc[[3,4,8],[0,1]]

# 8 Select only the rows where the number of visits is greater than 3.

df[df['visits'] > 3]

# 9  Select the rows where the age is missing, i.e. it is NaN

df[df['age'].isnull()]

# 10 Select the rows where the animal is a cat and the age is less than 3

df[(df['animal'] == 'cat') & (df['age'] < 3)]

# 11 Select the rows the age is between 2 and 4 (inclusive).

df[df['age'].between(2,4)]

# 12 Change the age in row 'f' to 1.5

df.loc['f','age'] = 1.5
df

# 13  Calculate the sum of all visits in df (i.e. find the total number of visits)
df['visits'].sum()

# 14 Calculate the mean age for each different animal in df.
df.groupby('animal')['age'].mean()

# 15 Append a new row 'k' to df with your choice of values for each column. Then delete that row to return the original DataFrame.
df.loc['k'] = ['dog',5.5,2,'yes']
df

df = df.drop('k')
df

# 16 Count the number of each type of animal in df.
df['animal'].value_counts()

# 17 Sort df first by the values in the 'age' in decending order, then by the value in the 'visits' column in ascending order (so row i should be first, and row d should be last).

df.sort_values(by=['age','visits'],ascending=[False,True])
df

# 18 The 'priority' column contains the values 'yes' and 'no'. Replace this column with a column of boolean values: 'yes' should be True and 'no' should be False

df['priority'] = df['priority'].map({'yes':True,'no':False})
df

# 19  In the 'animal' column, change the 'snake' entries to 'python
df['animal'] = df['animal'].replace('snake', 'python')
df

# 20 For each animal type and each number of visits, find the mean age. In other words, each row is an animal, each column is a number of visits and the values are the mean ages (hint: use a pivot table).
df.pivot_table(index='animal',columns='visits',values='age',aggfunc='mean')

df = pd.DataFrame({'A': [1, 2, 2, 3, 4, 5, 5, 5, 6, 7, 7]})
df

# 21 How do you filter out rows which contain the same integer as the row immediately above?

# shift() function is used to shift the values of a column or index by a specified number of periods (rows)

df.loc[df['A'].shift() != df['A']]

# 22 df = pd.DataFrame(np.random.random(size=(5, 3))) # a 5x3 frame of float values
# how do you subtract the row mean from each element in the row?

df = pd.DataFrame(np.random.random(size=(5, 3)))
df

# row wise substraction

df.sub(df.mean(axis=1),axis=0)

# this is column wise substraction
df[0] = df[0] - df[0].mean()
df[1] = df[1] - df[1].mean()
df[2] = df[2] - df[2].mean()

df

# 23
#Which column of numbers has the smallest sum? Return that column's label.

df = pd.DataFrame(np.random.random(size=(5, 10)), columns=list('abcdefghij'))
df.sum().idxmin()

# 24 How do you count how many unique rows a DataFrame has (i.e. ignore all rows that are duplicates)? As input, use a DataFrame of zeros and ones with 10 rows and 3 columns.

df = pd.DataFrame(np.random.randint(0, 2, size=(10, 3)))
len(df.drop_duplicates(keep=False))

# 25 In the cell below, you have a DataFrame df that consists of 10 columns of floating-point numbers.
# Exactly 5 entries in each row are NaN values. For each row of the DataFrame, find the column which contains the third NaN value.


nan = np.nan

data = [[0.04,  nan,  nan, 0.25,  nan, 0.43, 0.71, 0.51,  nan,  nan],
        [ nan,  nan,  nan, 0.04, 0.76,  nan,  nan, 0.67, 0.76, 0.16],
        [ nan,  nan, 0.5 ,  nan, 0.31, 0.4 ,  nan,  nan, 0.24, 0.01],
        [0.49,  nan,  nan, 0.62, 0.73, 0.26, 0.85,  nan,  nan,  nan],
        [ nan,  nan, 0.41,  nan, 0.05,  nan, 0.61,  nan, 0.48, 0.68]]

columns = list('abcdefghij')

df = pd.DataFrame(data, columns=columns)

(df.isnull().cumsum(axis=1) == 3).idxmax(axis=1)

# 26 For each group, find the sum of the three greatest values. You should end up with the answer as follows:

df = pd.DataFrame({'grps': list('aaabbcaabcccbbc'),
                   'vals': [12,345,3,1,45,14,4,52,54,23,235,21,57,3,87]})

df.groupby('grps')['vals'].apply(lambda x:x.nlargest(3).sum())

# 27 The DataFrame df constructed below has two integer columns 'A' and 'B'. The values in 'A' are between 1 and 100 (inclusive).

# For each group of 10 consecutive integers in 'A' (i.e. (0, 10], (10, 20], ...), calculate the sum of the corresponding values in column 'B

df = pd.DataFrame(np.random.RandomState(8765).randint(1, 101, size=(100, 2)), columns = ["A", "B"])

df.groupby(pd.cut(df['A'],np.arange(1,101,10)))['B'].sum()

# 28 Implement a rolling mean over groups with window size 3, which ignores NaN value. For example consider the following DataFrame:

df = pd.DataFrame({'group': list('aabbabbbabab'),
                       'value': [1, 2, 3, np.nan, 2, 3, np.nan, 1, 7, 3, np.nan, 8]})

g1 = df.groupby(['group'])['value']
g2 = df.fillna(0).groupby(['group'])['value']
s = g2.rolling(3, min_periods=1).sum() / g1.rolling(3, min_periods=1).count()
s.reset_index(level=0, drop=True).sort_index()

"""## DateTimeIndex"""

# 29 Create a DatetimeIndex that contains each business day of 2015 and use it to index a Series of random numbers

dt = pd.date_range(start='2015-01-01',end='2015-12-31',freq='B')

s = pd.Series(np.random.rand(len(dt)), index=dt)
s

# 30 Find the sum of the values in s for every Wednesday.

s[dt.weekday==2].sum()

# 31 For each calendar month in s, find the mean of values.

s.resample('M').mean()

# 32 For each group of four consecutive calendar months in s, find the date on which the highest value occurred.

s.groupby(pd.Grouper(freq='4M')).idxmax()

# 33 Create a DateTimeIndex consisting of the third Thursday in each month for the years 2015 and 2016.

pd.date_range('2015-01-01', '2016-12-31', freq='WOM-3THU')

"""## Data Cleaning"""

# 34 Some values in the the FlightNumber column are missing (they are NaN). These numbers are meant to increase by 10
#  with each row so 10055 and 10075 need to be put in place. Modify df to fill in these missing numbers
#  and make the column an integer column (instead of a float column).

df = pd.DataFrame({'From_To': ['LoNDon_paris', 'MAdrid_miLAN', 'londON_StockhOlm',
                               'Budapest_PaRis', 'Brussels_londOn'],
              'FlightNumber': [10045, np.nan, 10065, np.nan, 10085],
              'RecentDelays': [[23, 47], [], [24, 43, 87], [13], [67, 32]],
                   'Airline': ['KLM(!)', '<Air France> (12)', '(British Airways. )',
                               '12. Air France', '"Swiss Air"']})

df['FlightNumber'] = df['FlightNumber'].interpolate().astype(int)
df

# 35 The From_To column would be better as two separate columns! Split each string on the underscore delimiter _ to give
# a new temporary DataFrame called 'temp' with the correct values. Assign the correct column
#  names 'From' and 'To' to this temporary DataFrame.

df['From'],df['To'] = zip(*df['From_To'].apply(lambda x: x.split('_')))
df

# 36 Notice how the capitalisation of the city names is all mixed up in this temporary DataFrame 'temp'.
# Standardise the strings so that only the first letter is uppercase (e.g. "londON" should become "London".)

df['From'],df['To'] = df['From'].apply(lambda x: x.capitalize()),df['To'].apply(lambda x: x.capitalize())

# 37 Delete the From_To column from df
df = df.drop('From_To',axis=1)
df

# 38 In the Airline column, you can see some extra puctuation and symbols have appeared around the airline names.
# Pull out just the airline name. E.g. '(British Airways. )' should become 'British Airways'.

df['Airline'] = df['Airline'].str.extract('([a-zA-Z\s]+)', expand=False).str.strip()
df

# 39 In the RecentDelays column, the values have been entered into the DataFrame as a list.
# We would like each first value in its own column, each second value in its own column, and so on. If there isn't an Nth value,
#the value should be NaN.

delays = pd.DataFrame(df['RecentDelays'].tolist(), columns=['Delay1', 'Delay2', 'Delay3'])

# Combine the new columns with the original DataFrame
df = pd.concat([df, delays], axis=1)

print(df)

# 40  Given the lists letters = ['A', 'B', 'C'] and numbers = list(range(10)), construct a MultiIndex object from the
# product of the two lists. Use it to index a Series of random numbers. Call this Series s.



